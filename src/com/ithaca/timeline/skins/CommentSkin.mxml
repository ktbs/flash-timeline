<?xml version="1.0" encoding="utf-8"?>
<s:Skin xmlns:fx="http://ns.adobe.com/mxml/2009" 
				xmlns:s="library://ns.adobe.com/flex/spark" 
				xmlns:mx="library://ns.adobe.com/flex/mx" 
				width="100" height="100%"
				creationComplete="creationCompleteHandler(event)" 
				doubleClick="EditComment(event)" 
				click="onSelect(event)">
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<fx:Metadata>[HostComponent("com.ithaca.timeline.ObselSkin")]</fx:Metadata>
		
		<fx:Script>
        <![CDATA[

			import com.ithaca.timeline.CursorIcons;
			import com.ithaca.timeline.Stylesheet;
			import flash.events.MouseEvent;
			import gnu.as3.gettext._FxGettext;
			import gnu.as3.gettext.FxGettext;
			import mx.core.UIComponent;
			import mx.managers.PopUpManager;
			import spark.components.BorderContainer;
			import spark.components.Group;

			[Bindable]
			private 	var fxgt : _FxGettext;
			
			protected 	var currentCenterDragingPoint:Point;			
			private 	var draggedPart : UIComponent = null;
			public		var minX  :Number;
			public		var maxX  : Number;
		
			protected function creationCompleteHandler(event:Event):void
			{
				fxgt = FxGettext;
				y = 5;
				commentLabel.text = fxgt.gettext("Write your comment");
				toolTip = commentLabel.text;
			}

			protected function zcStartDrag(e:MouseEvent):void
			{
				onSelect(null);
				
				if ( e.currentTarget == icon )
					draggedPart = cursor;
				else
					draggedPart = (e.currentTarget as UIComponent);
				stage.addEventListener( MouseEvent.MOUSE_MOVE, 	zcDragging);
				stage.addEventListener( MouseEvent.MOUSE_UP,	zcStopDrag);				
					
				currentCenterDragingPoint = new Point(e.localX, e.localY);
			}
			
			protected function zcDragging(e:MouseEvent):void
			{				
				minX = 0;
				maxX = (hostComponent.traceline.width - 2 * Stylesheet.renderersSidePadding );				
				
				var parentMouse:Point = hostComponent.parent.globalToLocal(new Point(e.stageX, e.stageY));				
				var newPos : Number   = parentMouse.x - currentCenterDragingPoint.x;
								
				if (draggedPart == minRange )
				{					
					var oldPos : Number = hostComponent.x;						
					if ( newPos < minX  )						
						hostComponent.x = minX ;						
					else if ( newPos + minRange.width > hostComponent.x + maxRange.x - 1 )
						hostComponent.x =  hostComponent.x + maxRange.x - 1;
					else
						hostComponent.x = newPos + minRange.width;
					width 	-= hostComponent.x - oldPos ;	
				}
				else if (draggedPart == cursor )
				{
					if ( newPos < minX)						
						hostComponent.x  = minX;						
					else if ( newPos > maxX - width )
						hostComponent.x = maxX - width;
					else
						hostComponent.x = newPos;						
				} 
				else if (draggedPart == maxRange )
				{
					if ( newPos < hostComponent.x + 1 )
						maxRange.x =  1;
					else if (newPos > maxX )
						maxRange.x = maxX - hostComponent.x;
					else
						maxRange.x = newPos - hostComponent.x;
						
					width = maxRange.x;				
				}						
			}
			
			protected function zcStopDrag(e:MouseEvent):void
			{
				draggedPart = null;

				stage.removeEventListener(MouseEvent.MOUSE_MOVE,zcDragging);
				stage.removeEventListener(MouseEvent.MOUSE_UP, zcStopDrag);
			
				hostComponent.obsel.begin  = hostComponent.traceline._timeline.zoomContext.cursorRange.positionToTime( hostComponent.x, (hostComponent.traceline.width - 2 * Stylesheet.renderersSidePadding ) );
				hostComponent.obsel.end    = hostComponent.traceline._timeline.zoomContext.cursorRange.positionToTime( hostComponent.x + cursor.width, (hostComponent.traceline.width - 2 * Stylesheet.renderersSidePadding ) );
			}	
			
			protected function EditComment( e:MouseEvent ):void
			{
				this.enabled = false;

				var commentEditDialog:CommentEditDialog = new CommentEditDialog();
				commentEditDialog.commentText = commentLabel.text;
				PopUpManager.addPopUp(commentEditDialog, this);
				PopUpManager.centerPopUp(commentEditDialog);
				commentEditDialog.y -= commentEditDialog.height;
				commentEditDialog.addEventListener( Event.REMOVED_FROM_STAGE, onRemoveEditDialog );
			}
			
			private function onRemoveEditDialog(event:Event):void
			{
				if (event.currentTarget.confirm)
				{
					//TODO : il faut ecrire dans hostComponent.obsel.prop .... et pas dans le skin
					commentLabel.text = event.currentTarget.commentTextInput.text;
					
					toolTip = event.currentTarget.commentTextInput.text;
				}
				this.enabled = true;
			}
			
			private function onSelect(event:Event):void
			{
				(hostComponent.parent as Group).addElementAt( hostComponent, (hostComponent.parent as Group).numElements -1);
			}
			
        ]]>
    </fx:Script>
	
	<s:states>
		<s:State name="normal" />		
		<s:State name="edit" />
	</s:states>
	
	<s:BorderContainer id="minRange" backgroundColor="0" y="-5" borderColor="0" minWidth="1" minHeight="1" width="2" height="{cursor.height+5}"  x="{-minRange.width}"  mouseDown="zcStartDrag(event);" mouseOver="CursorIcons.SetResizeCursor(event)" mouseOut="CursorIcons.SetDefaultCursor(event)"/>
	<s:BorderContainer id="maxRange" backgroundColor="0"  y="-5" borderColor="0" minWidth="1" minHeight="1" width="2" height="{cursor.height+5}" x="{width}" mouseDown="zcStartDrag(event);" mouseOver="CursorIcons.SetResizeCursor(event)" mouseOut="CursorIcons.SetDefaultCursor(event)"/>

	<s:BorderContainer id="cursor" borderWeight="1"   backgroundColor="#FEFDD6" minWidth="1" minHeight="1" width="100%" height="100%"  >
		<mx:Image id="icon" source="{getStyle('icon')}" top="2" left="2" mouseDown="zcStartDrag(event);" mouseOver="CursorIcons.SetHandCursor(event)" mouseOut="CursorIcons.SetDefaultCursor(event)"/>
		<s:Label id="commentLabel" width="100%" height="20" fontSize="10" x="{icon.width+5}"  y="3"  mouseOver="CursorIcons.SetIBeamCursor(event)" mouseOut="CursorIcons.SetDefaultCursor(event)"    />
	</s:BorderContainer>
			
</s:Skin>